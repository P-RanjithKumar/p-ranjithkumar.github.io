<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Blog 5 | Ranjith Kumar</title>
  <!-- Include MathJax for rendering LaTeX equations -->
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <style>
    /* Reuse existing styles from the first blog */
    :root {
      --primary-color: #2d3436;
      --accent-color: #0984e3;
      --text-color: #2d3436;
      --hover-color: #74b9ff;
    }
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: 'Segoe UI', system-ui, sans-serif;
      line-height: 1.6;
      color: var(--text-color);
      margin: 0 auto;
      padding: 20px;
      max-width: 1200px;
    }
    .scroll-progress {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 4px;
      background: #eee;
      z-index: 1000;
    }
    .progress-bar {
      width: 0%;
      height: 100%;
      background: var(--accent-color);
    }
    .post-header {
      margin-bottom: 3rem;
      position: relative;
      padding-top: 10px;
    }
    .back-to-blog {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      text-decoration: none;
      color: var(--accent-color);
      margin-bottom: 2rem;
      transition: color 0.2s ease;
    }
    .back-to-blog:hover {
      color: var(--hover-color);
    }
    .post-meta {
      display: flex;
      gap: 15px;
      color: #636e72;
      font-size: 0.9em;
      margin: 1rem 0;
    }
    .post-content {
      display: grid;
      grid-template-columns: 1fr 250px;
      gap: 2rem;
    }
    .article-body {
      max-width: 800px;
      font-size: 1.1em;
      line-height: 1.8;
    }
    .article-body img {
      width: 100%;
      height: auto;
      border-radius: 8px;
      margin: 2rem 0;
    }
    .article-body h2,
    .article-body h3 {
      margin: 2rem 0 1rem;
      color: var(--primary-color);
    }
    .toc {
      position: sticky;
      top: 20px;
      align-self: start;
      padding: 1.5rem;
      background: #f8f9fa;
      border-radius: 8px;
    }
    .toc ul {
      list-style: none;
      padding-left: 1rem;
    }
    .toc a {
      color: var(--text-color);
      text-decoration: none;
      transition: color 0.2s ease;
      display: block;
      padding: 0.3rem 0;
    }
    .toc a:hover {
      color: var(--accent-color);
    }
    .post-navigation {
      margin: 4rem 0;
      display: flex;
      justify-content: space-between;
      border-top: 1px solid #eee;
      padding-top: 2rem;
    }
    .nav-button {
      padding: 12px 25px;
      text-decoration: none;
      border-radius: 25px;
      transition: all 0.2s ease;
    }
    .prev-post {
      background: var(--accent-color);
      color: white;
    }
    .next-post {
      background: #f1f2f6;
      color: var(--text-color);
    }
    .nav-button:hover {
      transform: translateY(-2px);
    }
    @media (max-width: 768px) {
      .post-content {
        grid-template-columns: 1fr;
      }
      .toc {
        position: static;
        margin-bottom: 2rem;
      }
      .post-navigation {
        flex-direction: column;
        gap: 1rem;
      }
    }
  </style>
</head>
<body>
  <!-- Scroll Progress Indicator -->
  <div class="scroll-progress">
    <div class="progress-bar"></div>
  </div>

  <header class="post-header">
    <a href="bloghome.html" class="back-to-blog">← Back to Blog</a>
    <h1>Diving into Reinforcement Learning and Attention Mechanisms</h1>
    <div class="post-meta">
      <span>Mar 7, 2025  •</span>
      <span>20 min read</span>
    </div>
    <div class="post-tags">
      <span class="tag">AI discussion  </span>
      <span class="tag">Deep Learning  </span>
      <span class="tag">Blogging</span>
    </div>
  </header>
 
  <div class="post-content">
    <article class="article-body">
      <img src="assets/blog_cover_image/ReinforcementLearning.png" alt="Blog post cover image" style="border-radius: 8px; width: 800px; height: 150px;">
      <p>Hi everyone! It’s been a couple of weeks since my last post—life got a bit busy, and I’ll admit I got distracted along the way. But I’m back now, and I’ve been diving deep into some exciting topics: Reinforcement Learning (RL), specifically off-policy algorithms like Q-learning, and the fascinating world of attention mechanisms in Large Language Models (LLMs). I’ve also been working on an RL-based Tic-Tac-Toe game, which is nearly complete except for some tricky training hurdles. Plus, I stumbled upon an amazing video that broke down different types of attention mechanisms—more on that later! In this post, I’ll walk you through what I’ve learned, the challenges I’ve faced, and why I’m so hooked on these topics. Let’s get started!</p>
      
      <h2 id="section1">Off-Policy RL Algorithms</h2>
      <p>Reinforcement Learning is all about teaching an agent to make smart decisions by interacting with an environment—like training a virtual pet to fetch a ball. RL algorithms come in two flavors: on-policy and off-policy. On-policy algorithms learn from the actions the agent takes based on its current strategy (or policy), while off-policy algorithms can learn from actions taken by different policies, even from past experiences or random moves. This flexibility allows off-policy methods to reuse old data effectively.</p>
      <p>My focus has been on Q-learning, a classic off-policy algorithm. Imagine you’re playing a game and trying to figure out the best move in every situation. Q-learning builds a “Q-table” that scores each possible action in each state—like a cheat sheet telling you how valuable each move is. Over time, it updates these scores based on rewards (e.g., +1 for a win) and potential future outcomes.</p>
      <div class="math" style="text-align:center; margin: 1rem 0;">
        \[
          Q(s, a) \leftarrow Q(s, a) + \alpha \left[ r + \gamma \max_{a'} Q(s', a') - Q(s, a) \right]
        \]
      </div>
      <p>Let’s break it down:</p>
      <ul>
        <li>\( s \): The current situation (state) you’re in.</li>
        <li>\( a \): The move (action) you choose.</li>
        <li>\( r \): The immediate reward you get (e.g., points for a good move).</li>
        <li>\( s' \): The new situation after your move.</li>
        <li>\( \alpha \): The learning rate—how quickly you update your cheat sheet (between 0 and 1).</li>
        <li>\( \gamma \): The discount factor—how much you care about future rewards (also between 0 and 1).</li>
        <li>\( \max_{a'} Q(s', a') \): The best possible score you could get in the next situation.</li>
      </ul>
      <p>Think of it like this: you’re tweaking your strategy a little (\( \alpha \)) based on what you just earned (\( r \)) plus a sneak peek at the best future outcome, adjusted by how much you value the long game (\( \gamma \)). Q-learning is especially useful in robotics or game AI, where the agent learns optimal moves without needing a strict playbook.</p>
      
      <!-- Tic Tac Toe RL Training Content -->
<section id="tic-tac-toe-training">
    <h2>Training an RL Model for Tic Tac Toe: A Step-by-Step Guide</h2>
    
    <p>
      Tic Tac Toe is a classic board game that, despite its simplicity, provides a fantastic testbed for Reinforcement Learning (RL). In this guide, we’ll walk through the detailed process of training an RL agent—using methods like Q-learning—to master Tic Tac Toe. Every step is broken down so that even if you’re new to RL, you can understand the rationale and techniques behind each decision.
    </p>
    
    <h3>1. Understanding the Environment and Game Dynamics</h3>
    <p>
      In Tic Tac Toe, the <strong>environment</strong> is the game board—a 3x3 grid where each cell can be empty, marked with an “X”, or an “O”. The RL agent interacts with this environment by placing its mark on the board. The game can result in a win, loss, or draw, and we assign:
    </p>
    <ul>
      <li><strong>+1 reward</strong> for a win</li>
      <li><strong>0 reward</strong> for a draw</li>
      <li><strong>-1 reward</strong> for a loss</li>
    </ul>
    
    <h3>2. State Representation and Q-Table Initialization</h3>
    <p>
      To allow our agent to learn, we first need a way to represent each state of the board. A common approach is:
    </p>
    <ul>
      <li>
        <strong>Encoding the Board:</strong> Represent the 3x3 grid as a vector or a unique number. For instance, you can assign each cell a value (e.g., 0 for empty, 1 for “X”, -1 for “O”) and then flatten the grid into an array. Alternatively, you can generate a unique key for each board configuration.
      </li>
      <li>
        <strong>Q-Table:</strong> The Q-table is a lookup table where each key corresponds to a state and each value is an array that holds the Q-value for each possible action (i.e., placing a mark in one of the empty cells). Initially, all Q-values are set to zero.
      </li>
    </ul>
    
    <h3>3. Action Selection: Balancing Exploration and Exploitation</h3>
    <p>
      To train effectively, the agent must both explore new moves and exploit known rewarding moves. This is typically handled by an <strong>epsilon-greedy policy</strong>:
    </p>
    <ul>
      <li>
        With probability <em>ε</em> (epsilon), choose a random move (exploration).
      </li>
      <li>
        With probability <em>1 - ε</em>, select the move with the highest Q-value for the current state (exploitation).
      </li>
    </ul>
    <p>
      Over time, epsilon is usually decayed so that the agent explores less and exploits more once it has gained sufficient knowledge.
    </p>
    
    <h3>4. The Q-Learning Update Rule</h3>
    <p>
      At the heart of training the agent is the Q-learning update rule. When the agent takes an action, it observes the resulting reward and the next state, and then updates its Q-value for the state-action pair using the formula:
    </p>
    <div style="text-align: center; margin: 1rem 0;">
      \[
        Q(s, a) \leftarrow Q(s, a) + \alpha \left[ r + \gamma \max_{a'} Q(s', a') - Q(s, a) \right]
      \]
    </div>
    <p>
      Here:
    </p>
    <ul>
      <li><strong>\(s\)</strong>: Current state (the board configuration before the move).</li>
      <li><strong>\(a\)</strong>: Action taken (the move made).</li>
      <li><strong>\(r\)</strong>: Immediate reward (win, draw, or loss).</li>
      <li><strong>\(s'\)</strong>: Next state (the board after the move).</li>
      <li><strong>\(\alpha\)</strong>: Learning rate, determining how fast the agent updates its knowledge.</li>
      <li><strong>\(\gamma\)</strong>: Discount factor, indicating the importance of future rewards.</li>
      <li><strong>\(\max_{a'} Q(s', a')\)</strong>: The maximum predicted future reward for the next state.</li>
    </ul>
    <p>
      This rule helps the agent refine its “cheat sheet” (the Q-table) by blending immediate feedback with its estimation of long-term benefits.
    </p>
    
    <h3>5. Training Loop and Episode Iteration</h3>
    <p>
      Training an RL agent for Tic Tac Toe involves running multiple episodes of the game. In each episode:
    </p>
    <ol>
      <li>
        <strong>Reset the Environment:</strong> Start with an empty board.
      </li>
      <li>
        <strong>Play a Game:</strong> The agent (or two agents playing against each other) makes moves until the game ends.
      </li>
      <li>
        <strong>Update Q-Values:</strong> After each move, update the Q-table using the Q-learning rule.
      </li>
      <li>
        <strong>End of Episode:</strong> Once the game concludes (win, loss, or draw), record the outcome and reset the board for the next episode.
      </li>
    </ol>
    <p>
      By iterating over thousands of episodes, the agent gradually learns which moves lead to success. You can monitor the performance by periodically evaluating the win/draw/loss ratio.
    </p>
    
    <h3>6. Challenges and Considerations</h3>
    <p>
      Although Tic Tac Toe has a limited number of board configurations (roughly 5,478 unique states after accounting for symmetry), there are several challenges:
    </p>
    <ul>
      <li>
        <strong>State Space Redundancy:</strong> Many board states are equivalent under rotation or reflection. Recognizing these can help reduce redundant learning.
      </li>
      <li>
        <strong>Exploration vs. Exploitation:</strong> Finding the right balance is critical. Too much exploration can slow learning, while too much exploitation can trap the agent in suboptimal strategies.
      </li>
      <li>
        <strong>Hyperparameter Tuning:</strong> Choosing appropriate values for the learning rate (\(\alpha\)), discount factor (\(\gamma\)), and exploration rate (\(\epsilon\)) is essential for effective training.
      </li>
    </ul>
    
    <h3>7. Optimizing Training</h3>
    <p>
      To further enhance performance:
    </p>
    <ul>
      <li>
        <strong>Vectorized Operations:</strong> If implementing in Python, use libraries like NumPy to perform batch updates and speed up computations.
      </li>
      <li>
        <strong>State Hashing:</strong> Use efficient data structures to quickly retrieve and update Q-values for board states.
      </li>
      <li>
        <strong>Curriculum Learning:</strong> Start with simpler scenarios (e.g., fewer moves or restricted board areas) before moving to full-game training.
      </li>
    </ul>
    
    <p>
      With these steps and considerations, you can build an RL agent that learns to play Tic Tac Toe effectively, gaining insights that can be transferred to more complex environments.
    </p>
  </section>

  <br><br>
  <hr width="100%" size="2">
  
  <!-- Detailed Explanation of Different Types of Attention Mechanisms -->
  <section id="attention-mechanisms">
    <h2>Understanding Attention Mechanisms in Deep Learning: A Detailed Guide</h2>
    <p>
      Attention mechanisms have revolutionized how models process sequences, allowing them to focus on the most relevant parts of the input. In this section, we break down the different types of attention—explaining their workings step by step so that the underlying mathematics and intuition become crystal clear.
    </p>
    
    <h3>A. Self-Attention .....</h3>
    <p>
      Self-attention is the fundamental building block behind many modern language models. It allows every element of a sequence (e.g., each word in a sentence) to interact with every other element, determining the importance of one word in the context of another.
    </p>
    <ol>
      <li>
        <strong>Input Representation:</strong> Every word in the input sequence is converted into a high-dimensional vector (embedding) that captures its semantic meaning.
      </li>
      <li>
        <strong>Linear Projections:</strong> For each word, three vectors are derived using learned linear transformations:
        <ul>
          <li><em>Query (Q):</em> Represents the word’s request for contextual information.</li>
          <li><em>Key (K):</em> Encodes the word’s content that might be relevant to others.</li>
          <li><em>Value (V):</em> Contains the actual information that will be aggregated.</li>
        </ul>
      </li>
      <li>
        <strong>Score Calculation:</strong> For a given word, compute the dot product between its query vector and the key vectors of every word in the sequence. This yields a score for each word pair, quantifying their compatibility.
      </li>
      <li>
        <strong>Scaling:</strong> Divide the dot products by \(\sqrt{d_k}\) (where \(d_k\) is the dimension of the key vectors) to stabilize gradients during training.
      </li>
      <li>
        <strong>Softmax Normalization:</strong> Apply the softmax function to the scaled scores to convert them into a probability distribution (attention weights) that sums to 1.
      </li>
      <li>
        <strong>Weighted Sum:</strong> Multiply each value vector by its corresponding attention weight and sum the results to obtain the final representation for the word.
      </li>
    </ol>
    <p style="text-align: center; margin: 1rem 0;">
      \[
        \text{Attention}(Q, K, V) = \text{softmax}\left(\frac{QK^T}{\sqrt{d_k}}\right) V
      \]
    </p>
    <p>
      In essence, self-attention enables the model to dynamically reassemble information by highlighting which words in the sentence are most relevant to each other.
    </p>
    
    <h3>B. Multi-Head Attention .....</h3>
    <p>
      Multi-head attention extends self-attention by running multiple attention mechanisms, or “heads,” in parallel. This allows the model to capture different types of relationships and features from the input.
    </p>
    <ol>
      <li>
        <strong>Multiple Projections:</strong> The input embeddings are projected into multiple sets of Q, K, and V vectors—one set for each head. Each head is trained to focus on different aspects of the input.
      </li>
      <li>
        <strong>Parallel Attention Computation:</strong> Each head computes attention independently using the same self-attention mechanism:
        <div style="text-align: center; margin: 1rem 0;">
          \[
            \text{head}_i = \text{Attention}(QW_i^Q, KW_i^K, VW_i^V)
          \]
        </div>
      </li>
      <li>
        <strong>Concatenation and Final Projection:</strong> The outputs from all heads are concatenated and passed through a final linear layer to combine the information:
        <div style="text-align: center; margin: 1rem 0;">
          \[
            \text{MultiHead}(Q, K, V) = \text{Concat}(\text{head}_1, \dots, \text{head}_h) W^O
          \]
        </div>
      </li>
    </ol>
    <p>
      By attending to different parts of the sequence in parallel, multi-head attention enriches the model’s capacity to understand complex and varied dependencies.
    </p>
    
    <h3>C. Grouped Query Attention .....</h3>
    <p>
      Grouped Query Attention is designed to reduce the computational overhead inherent in the full attention mechanism. Instead of processing each query independently, similar queries are grouped together, which allows the model to share computations:
    </p>
    <ol>
      <li>
        <strong>Clustering Queries:</strong> Identify queries that are similar or share common characteristics. These queries are grouped so that their attention calculations can be computed collectively.
      </li>
      <li>
        <strong>Shared Computation:</strong> Compute the attention scores for the grouped queries as a batch, reducing the total number of individual operations required.
      </li>
      <li>
        <strong>Efficiency Trade-Off:</strong> While grouping might introduce a slight approximation error, the reduction in computation significantly speeds up the process, especially beneficial for very large models.
      </li>
    </ol>
    <p>
      This approach allows models to maintain high accuracy while scaling to longer sequences or larger datasets.
    </p>
</section>
    
    <h3>D. Multi Latent Attention Mechanism .....</h3>
    
    <p>
      In the evolving landscape of deep learning, attention mechanisms play a critical role in capturing complex dependencies within input sequences. DeepSeek has introduced an innovative approach known as the <strong>Multi Latent Attention Mechanism</strong> (MLAM), which leverages latent variable modeling to dynamically extract, aggregate, and fuse multiple levels of context while significantly reducing computational overhead. In this section, we delve into the technical depths of MLAM, detailing its theoretical foundations, mathematical formulation, algorithmic steps, and comparative advantages.
    </p>
    
    <h3>Theoretical Foundations and Motivation</h3>
    <p>
      Traditional attention mechanisms—such as self-attention and multi-head attention—tend to compute pairwise interactions between all tokens in an input sequence. While effective, these methods scale quadratically (O(n²)) with sequence length, which can become a bottleneck in processing long sequences. To overcome this, MLAM introduces latent variables that capture the underlying structure of the input data. Instead of attending to every token explicitly, the model projects the input into a lower-dimensional latent space, where key patterns and relationships are distilled into a compact representation.
    </p>
    
    <h3>Mathematical Formulation</h3>
    <p>
      The Multi Latent Attention Mechanism can be conceptually divided into three major stages:
    </p>
    <ol>
      <li>
        <strong>Latent Variable Extraction:</strong> Given an input sequence represented by embeddings \( X \in \mathbb{R}^{n \times d} \) (with \( n \) tokens and dimension \( d \)), MLAM first projects these embeddings into \( L \) latent components using a set of learned linear transformations:
        <div style="text-align: center; margin: 1rem 0;">
          \[
            Z = f(X; W_Z) \quad \text{where} \quad Z \in \mathbb{R}^{n \times L}
          \]
        </div>
        Here, \( W_Z \) denotes the projection matrix, and \( Z \) encapsulates the latent features.
      </li>
      <li>
        <strong>Latent Attention Computation:</strong> For each latent component, separate query, key, and value projections are computed. The attention scores for each latent channel are calculated by comparing the latent queries with the keys, scaled appropriately:
        <div style="text-align: center; margin: 1rem 0;">
          \[
            \text{Attention}_l(Q_l, K_l, V_l) = \text{softmax}\left(\frac{Q_l K_l^T}{\sqrt{d_k}}\right) V_l \quad \text{for } l = 1, 2, \ldots, L
          \]
        </div>
        Each \( Q_l, K_l, V_l \) is derived from the latent representation \( Z \) via dedicated projection matrices.
      </li>
      <li>
        <strong>Aggregation and Fusion:</strong> The outputs from the \( L \) latent attention channels are then concatenated and passed through a final linear transformation to produce the final context-aware representation:
        <div style="text-align: center; margin: 1rem 0;">
          \[
            \text{MLAM}(Q, K, V) = \text{Concat}(\text{Attention}_1, \ldots, \text{Attention}_L) W^O
          \]
        </div>
        Here, \( W^O \) is the output weight matrix that fuses the latent attention outputs into a coherent signal.
      </li>
    </ol>
    
    <h3>Algorithmic Steps</h3>
    <ol>
      <li>
        <strong>Input Projection:</strong> Transform the input embeddings \( X \) into latent space \( Z \) using a learned projection.
      </li>
      <li>
        <strong>Latent Splitting:</strong> For each of the \( L \) latent components, generate corresponding query (\( Q_l \)), key (\( K_l \)), and value (\( V_l \)) vectors.
      </li>
      <li>
        <strong>Attention Scoring:</strong> Compute the scaled dot-product attention for each latent component using the formula above.
      </li>
      <li>
        <strong>Aggregation:</strong> Concatenate the outputs from all latent channels.
      </li>
      <li>
        <strong>Final Fusion:</strong> Apply a linear transformation to integrate the aggregated attention into the final output representation.
      </li>
    </ol>
    
    <h3>Comparative Analysis of Attention Mechanisms</h3>
    <p>
      The following table compares key attributes of various attention mechanisms, highlighting the distinctive features and computational benefits of the Multi Latent Attention Mechanism.
    </p>
    <table border="1" cellspacing="0" cellpadding="5">
      <thead>
        <tr>
          <th>Mechanism</th>
          <th>Description</th>
          <th>Computational Complexity</th>
          <th>Key Features</th>
          <th>Advantages</th>
          <th>Disadvantages</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Self-Attention</td>
          <td>Each token attends to every other token in the sequence.</td>
          <td>O(n²)</td>
          <td>Global context; simplicity</td>
          <td>Effective for moderate sequence lengths</td>
          <td>Scales poorly with longer sequences</td>
        </tr>
        <tr>
          <td>Multi-Head Attention</td>
          <td>Multiple attention heads compute parallel attention in different subspaces.</td>
          <td>O(h * n²), with h heads</td>
          <td>Diverse representation; rich context capture</td>
          <td>Improved modeling capacity over single-head attention</td>
          <td>Increased computational cost</td>
        </tr>
        <tr>
          <td>Grouped Query Attention</td>
          <td>Clusters similar queries to share computations and reduce redundancy.</td>
          <td>Below O(n²), dependent on grouping efficiency</td>
          <td>Efficiency through query grouping</td>
          <td>Lower computation with minor approximation</td>
          <td>Potential loss in fine-grained detail</td>
        </tr>
        <tr>
          <td>Multi Latent Attention (DeepSeek)</td>
          <td>Uses latent variable modeling to extract and aggregate multiple latent representations.</td>
          <td>Approximately O(L * n), where L ≪ n</td>
          <td>Dynamic latent extraction; efficient fusion; scalability</td>
          <td>Reduces computational overhead significantly; excels with long sequences; enhanced real-time performance</td>
          <td>Higher model complexity; requires careful tuning of latent dimensions</td>
        </tr>
      </tbody>
    </table>
    
    <h3>Implementation Considerations</h3>
    <p>
      Implementing MLAM demands careful attention to several design aspects:
    </p>
    <ul>
      <li>
        <strong>Latent Dimension Selection:</strong> The number of latent components \( L \) must be balanced; too few may limit expressiveness, whereas too many can lead to overfitting and unnecessary computational burden.
      </li>
      <li>
        <strong>Projection Layers:</strong> Extend standard Q, K, and V projections to generate distinct latent vectors. This requires additional parameters and careful initialization.
      </li>
      <li>
        <strong>Normalization and Scaling:</strong> Incorporate normalization techniques such as layer normalization and appropriate scaling (e.g., division by \( \sqrt{d_k} \)) to stabilize the gradients during training.
      </li>
      <li>
        <strong>Fusion Strategy:</strong> The concatenation and final projection \( W^O \) must be designed to effectively merge diverse latent insights, ensuring that critical information is preserved.
      </li>
    </ul>
    
    <h3>Empirical Performance and Applications</h3>
    <p>
      Empirical studies have shown that the Multi Latent Attention Mechanism can significantly accelerate model inference and training, particularly in scenarios involving long text sequences or real-time applications. This mechanism is ideally suited for advanced language models, recommendation systems, and other tasks where efficiency and scalability are paramount.
    </p>
    
    <h3 id="section4">Conclusion</h3>
    <p>
      DeepSeek’s Multi Latent Attention Mechanism marks a substantial leap in attention-based modeling. By incorporating latent variable modeling, MLAM not only reduces the computational complexity but also enriches the contextual representation by dynamically aggregating multiple latent factors. This approach sets the stage for the next generation of AI applications, offering unparalleled efficiency and robust performance in handling complex, real-world data.
    </p>
  
  
  
      <!-- Post Navigation -->
      <div class="post-navigation">
        <a href="blog4.html" class="nav-button prev-post">← Previous Post</a>
        <a href="blog_all_caught_up.html" class="nav-button next-post">Next Post →</a>
      </div>
    </article>

    <!-- Table of Contents -->
    <aside class="toc">
      <h3>Table of Contents</h3>
      <ul>
        <li><a href="#section1">Off-Policy RL Algorithms</a></li>
        <li><a href="#tic-tac-toe-training">Tic-Tac-Toe Game Project</a></li>
        <li><a href="#attention-mechanisms">Attention Mechanisms in LLMs</a></li>
        <li><a href="#section4">Conclusion</a></li>
      </ul>
    </aside>
  </div>

  <script>
    // Scroll Progress Indicator
    window.addEventListener('scroll', () => {
      const winScroll = document.body.scrollTop || document.documentElement.scrollTop;
      const height = document.documentElement.scrollHeight - document.documentElement.clientHeight;
      const scrolled = (winScroll / height) * 100;
      document.querySelector('.progress-bar').style.width = scrolled + "%";
    });

    // Smooth Scroll for Table of Contents
    document.querySelectorAll('.toc a').forEach(anchor => {
      anchor.addEventListener('click', function(e) {
        e.preventDefault();
        const section = document.querySelector(this.getAttribute('href'));
        section.scrollIntoView({ behavior: 'smooth' });
      });
    });

    // Estimated Reading Time
    const postContent = document.querySelector('.article-body');
    const words = postContent.innerText.split(' ').length;
    const readingTime = Math.ceil(words / 200);
    document.querySelector('.post-meta span:nth-child(3)').innerHTML = `${readingTime} min read`;
  </script>
</body>
</html>
